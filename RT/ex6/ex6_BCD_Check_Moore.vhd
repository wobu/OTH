-- This file was generated by				
-- Qfsm Version 0.53					
-- (C) Stefan Duffner, Rainer Strobel			


-- Inputs:   a
-- State/Output valid counter
-- Q0           0     0       
-- Q1           0     0       
-- Q2           0     0       
-- Q3           0     0       
-- Q4           1     1       
-- Q5           0     0       
-- Q6           0     0       
-- Q7           0     0       
-- Q8           1     1       
-- Q9           1     1       
-- Q10          0     0       
-- Q11          0     0       
-- Q12          0     1       

LIBRARY IEEE;

USE IEEE.std_logic_1164.ALL;

ENTITY BCD_check IS
  PORT (clk: IN std_ulogic;
        rst_n: IN std_ulogic;
        a: IN std_ulogic;
        valid: OUT std_ulogic;
        counter: OUT std_ulogic);
END BCD_check;

ARCHITECTURE behave OF BCD_check IS

TYPE state_type IS (Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7, Q8, Q9, Q10, Q11, Q12);
SIGNAL next_state, current_state : state_type;

BEGIN
  state_register: PROCESS (rst_n, clk)
  BEGIN
    IF rst_n='0' THEN
      current_state <= Q0;
    ELSIF rising_edge(clk) THEN
      current_state <= next_state;
    END IF;
  END PROCESS;

  next_state_and_output_logic: PROCESS (current_state, a)
    VARIABLE temp_input : std_ulogic_vector(0 DOWNTO 0);
    VARIABLE temp_output : std_ulogic_vector(1 DOWNTO 0);
  BEGIN
    temp_input(0) := a;
    CASE current_state IS
      WHEN Q0 => temp_output := "00";
        IF temp_input="0" THEN
          next_state <= Q1;
        ELSIF temp_input="1" THEN
          next_state <= Q5;
        ELSE
          next_state <= current_state;
        END IF;
      WHEN Q1 => temp_output := "00";
        IF temp_input="0" THEN
          next_state <= Q2;
        ELSIF temp_input="1" THEN
          next_state <= Q2;
        ELSE
          next_state <= current_state;
        END IF;
      WHEN Q2 => temp_output := "00";
        IF temp_input="0" THEN
          next_state <= Q3;
        ELSIF temp_input="1" THEN
          next_state <= Q3;
        ELSE
          next_state <= current_state;
        END IF;
      WHEN Q3 => temp_output := "00";
        IF temp_input="0" THEN
          next_state <= Q4;
        ELSIF temp_input="1" THEN
          next_state <= Q4;
        ELSE
          next_state <= current_state;
        END IF;
      WHEN Q4 => temp_output := "11";
        IF temp_input="0" THEN
          next_state <= Q1;
        ELSIF temp_input="1" THEN
          next_state <= Q5;
        ELSE
          next_state <= current_state;
        END IF;
      WHEN Q5 => temp_output := "00";
        IF temp_input="0" THEN
          next_state <= Q6;
        ELSIF temp_input="1" THEN
          next_state <= Q10;
        ELSE
          next_state <= current_state;
        END IF;
      WHEN Q6 => temp_output := "00";
        IF temp_input="0" THEN
          next_state <= Q7;
        ELSIF temp_input="1" THEN
          next_state <= Q11;
        ELSE
          next_state <= current_state;
        END IF;
      WHEN Q7 => temp_output := "00";
        IF temp_input="0" THEN
          next_state <= Q8;
        ELSIF temp_input="1" THEN
          next_state <= Q9;
        ELSE
          next_state <= current_state;
        END IF;
      WHEN Q8 => temp_output := "11";
        IF temp_input="1" THEN
          next_state <= Q5;
        ELSIF temp_input="0" THEN
          next_state <= Q1;
        ELSE
          next_state <= current_state;
        END IF;
      WHEN Q9 => temp_output := "11";
        IF temp_input="1" THEN
          next_state <= Q5;
        ELSIF temp_input="0" THEN
          next_state <= Q1;
        ELSE
          next_state <= current_state;
        END IF;
      WHEN Q10 => temp_output := "00";
        IF temp_input="0" THEN
          next_state <= Q11;
        ELSIF temp_input="1" THEN
          next_state <= Q11;
        ELSE
          next_state <= current_state;
        END IF;
      WHEN Q11 => temp_output := "00";
        IF temp_input="1" THEN
          next_state <= Q12;
        ELSIF temp_input="0" THEN
          next_state <= Q12;
        ELSE
          next_state <= current_state;
        END IF;
      WHEN Q12 => temp_output := "01";
        IF temp_input="0" THEN
          next_state <= Q1;
        ELSIF temp_input="1" THEN
          next_state <= Q5;
        ELSE
          next_state <= current_state;
        END IF;
      WHEN OTHERS => temp_output := (OTHERS =>'X');
      next_state <= Q0;
    END CASE;
    valid <= temp_output(1);
    counter <= temp_output(0);
  END PROCESS;

END behave;
